---
layout: post
title: "Salvaging wrong solutions"
head_title: "Wrong solutions"
---

Recently, I seem to have developed a tendency to come up with blatantly wrong solutions whenever the
problem involves trees. Here are two examples.

## [Codeforces Round #601 Problem D][D]

This problem boils down to supporting $$ q $$ queries on a tree $$ T $$, where the queries are one
of the following:

1. Given a vertex $$ u $$, consider each connected component $$ S $$ in $$ T \setminus \{u\} $$, and
	 update the value of each vertex in $$ S $$ with $$ |T \setminus S|/|T| $$.
2. Output the value of a given vertex.

We need to handle these queries fast, because $$ n=|T| $$ goes up to $$ 10^5 $$ and there are a lot
of queries. I know how to update subtrees and query single vertices in $$ O(\log(n)) $$ each (using
a segment tree), and removing a vertex only creates two connected components which are subtrees, so
I thought this problem is pretty easy. I coded the segment tree, and for each query of type 1 with
vertex $$ u $$, updated the subtrees rooted at the children of $$ u $$. Now this runs in $$O(n\log(n))$$
per query, for a total time complexity of $$O(qn\log(n))$$ instead of $$O(q\log(n))$$ which I had
initially calculated. Of course, removing a vertex $$u$$ from a tree creates $$\deg(u)$$ connected
components, not two.

## [Educational Codeforces Round 77 Problem F][F]


[D]: https://codeforces.com/contest/1254/problem/D
[F]: https://codeforces.com/contest/1260/problem/F
